open Fake.Core
open Fake.IO
open Fake.IO.FileSystemOperators
open FSharp.Data
open Microsoft.Data.Sqlite
open System
open System.IO
open System.Web


module Tool =

    let run cmd args =
        CreateProcess.fromRawCommandLine cmd args
        |> CreateProcess.ensureExitCode
        |> Proc.run
        |> ignore

    let git = run "git"

let withCWD path fn =
    let prevDir = Directory.GetCurrentDirectory () 
    Directory.SetCurrentDirectory path

    fn()

    Directory.SetCurrentDirectory prevDir

let buildSources () =

    Directory.SetCurrentDirectory "work"

    let projects =
        [ {| Dir = "fsharp-core-docs"
             Repo = "git@github.com:fsharp/fsharp-core-docs.git"
             Build = fun () ->
                Tool.run "dotnet" "restore FSharp.Core"
                let fsdocs = "."</>"FSharp.Formatting"</>"src"</>"fsdocs-tool"</>"bin"</>"Release"</>"net5.0"</>"fsdocs.dll"
                Tool.run "dotnet" $"%s{fsdocs} build --sourcefolder fsharp" |}

          {| Dir = "fsharp-core-docs" </> "FSharp.Formatting"
             Repo = "git@github.com:fsprojects/FSharp.Formatting.git"
             Build = fun () ->
                Tool.run
                    (if Environment.isWindows then ".\\build.cmd" else "./build.sh")
                    "-t Build" |}

          {| Dir = "fsharp-core-docs" </> "fsharp"
             Repo = "git@github.com:dotnet/fsharp.git"
             Build = fun () ->
                if Environment.isWindows
                then ".\\Build.cmd", "-noVisualStudio"
                else "./build.sh", ""
                ||> Tool.run |}
        ]

    printfn ""
    printfn ""
    printfn "====> fetching repos"
    printfn ""
    printfn "" 

    projects
    |> List.iter (fun proj ->
        if not <| Directory.Exists proj.Dir then
            Tool.git $"clone --depth 1 %s{proj.Repo} %s{proj.Dir}"
        else
            fun _ -> Tool.git "pull"
            |> withCWD proj.Dir)

    projects
    |> List.rev
    |> List.iter (fun proj ->
        printfn ""
        printfn ""
        printfn $"====> building %s{proj.Dir}"
        printfn ""
        printfn ""

        proj.Build |> withCWD proj.Dir)

    Directory.SetCurrentDirectory ".."


[<AutoOpen>]
module Source =
    type IndexJson = JsonProvider<"""
        [
            {
                "uri": "https://fsharp.github.io/fsharp-core-docs/index.html",
                "title": "F# Core Library Documentation\n",
                "content": "\n# F# Core Library Documentation\n\nThis site contains the documentation for the FSharp.Core library used in all F# code.\n\nFSharp.Core contains functionality for basic F# definitions, operations for collections such as lists, maps and sequences,\nand library functionality for quotations, reflections, events, asynchronous programming and native interoperability.\n\nThe following namespaces are available:\n\n* [FSharp.Core](reference/fsharp-core.html) - Basic definitions of options, functions, operators, results and formatting.\n\n* [FSharp.Collections](reference/fsharp-collections.html) - Operations for collections such as lists, arrays, sets, maps and sequences. See also [F# Collection Types](https://docs.microsoft.com/dotnet/fsharp/language-reference/fsharp-collection-types) in the F# Language Guide.\n\n* [FSharp.Control](reference/fsharp-control.html) - Library functionality for asynchronous programming, events and agents. See also [F# Asynchronous Programming](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows) in the F# Language Guide.\n\n* [FSharp.Linq](reference/fsharp-linq.html) - Library functionality for F# query syntax and interoperability with .NET Expressions. See also [F# Query Expressions](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/query-expressions) in the F# Language Guide.\n\n* [FSharp.Quotations](reference/fsharp-quotations.html) - Library functionality for F# quotations. See also [F# Code Quotations](https://docs.microsoft.com/dotnet/fsharp/language-reference/code-quotations) in the F# Language Guide.\n\n* [FSharp.Reflection](reference/fsharp-reflection.html) - Library functionality for accessing additional information about F# types and F# values at runtime, augmenting that available through [System.Reflection](https://docs.microsoft.com/dotnet/api/system.reflection). See also [F# Reflection](https://en.wikibooks.org/wiki/F_Sharp_Programming/Reflection) in the F# Wiki Book.  \n\n* [FSharp.NativeInterop](reference/fsharp-nativeinterop.html) - Basic functionality for native interopability. See also [F# External Functions](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/external-functions) in the F# Language Guide. \n\n* [FSharp.Core.CompilerServices](reference/fsharp-core-compilerservices.html) - Library functionality for supporting type providers and code generated by the F# compiler. See also [F# Type Providers](https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/) in the F# Language Guide. \n\n## Contributing to this documentation\n\nTo contribute to this documentation site and its content, please see [the notes in the corresponding GitHub repository](https://github.com/fsharp/fsharp-core-docs).\n"
            }
        ]""">

    // type NamespaceHtml = HtmlProvider<"https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core.html">
    // type ModuleHtml = HtmlProvider<"https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-stringmodule.html">
    // type TypeHtml = HtmlProvider<"https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-option-1.html">

[<AutoOpen>]
module Docset =
    type EntryType =
        | Namespace
        | Type
        | Module

        // | Module
        // | Function
        // | Record
        // | Field
        // | Class
        // | Constructor
        // | Method
        // | Property
        // | Operator
        // | Constant

    type Entry =
        { Name: string
          Type: EntryType
          Path: string }

let buildDocSet () =

    let sourceDir = __SOURCE_DIRECTORY__ </> ".." </> "work" </> "fsharp-core-docs" </> "output"

    let docsetPath = __SOURCE_DIRECTORY__ </> ".." </> "work"</>"FSharp.Core.docset"
    let contentsPath = docsetPath</>"Contents"
    let resourcesPath = contentsPath</>"Resources"
    let documentsPath = resourcesPath</>"Documents"

    Shell.cleanDir docsetPath
    Directory.create (documentsPath)

    let uriPrefix = "https://fsharp.github.io/fsharp-core-docs/reference/"

    let filesAndEntries =
        IndexJson.Load (sourceDir </> "index.json")
        |> Seq.filter (fun el -> el.Uri.StartsWith uriPrefix)
        |> Seq.groupBy (fun el -> el.Uri.Split '#' |> Array.head)
        |> Seq.map (fun (uri, els) ->
            let filename =
                uriPrefix
                |> String.length
                |> uri.Substring
            let doc =
                sourceDir </> "reference" </> filename
                |> HtmlDocument.Load

            let html =
                let htmlNode = HtmlDocument.html doc
                let headHtml =
                    htmlNode
                    |> HtmlNode.descendantsNamed false ["head"]
                    |> Seq.head
                    |> HtmlNode.elements
                    |> List.map string
                    |> String.concat ""
                    |> string
                let bodyHtml =
                    htmlNode
                    |> HtmlNode.descendantsNamed false ["body"]
                    |> Seq.head
                    |> HtmlNode.elements
                    |> List.filter (fun el -> HtmlNode.name el <> "nav")
                    |> List.map string
                    |> String.concat ""
                let schmodderStyle = """<style type="text/css">
                    body { margin-left: 0 !important; }
                    .container { margin-left: 0 !important; margin-right: 0 !important; }
                    #fsdocs-content pre { overflow-x: auto; max-width: 550px;  }
                    </style>""" 
                $"""<!DOCTYPE html><html lang=en><head>%s{headHtml}%s{schmodderStyle}</head><body style="margin-left: 0 !important;">%s{bodyHtml}</body></html>"""
                |> String.replace uriPrefix String.Empty

            // TODO: copy/download styles for offline use

            let entries =
                els
                |> Seq.map (fun el ->
                    let name = HttpUtility.UrlEncode el.Title

                    let typ =
                        doc.CssSelect "#fsdocs-content > div > h2"
                        |> function
                        | h2 :: _ -> h2.InnerText().Trim().Split ' ' |> Array.last |> String.toLower
                        | [] -> failwith $"no h2 found in %s{filename}"
                        |> function
                        | "namespace" -> Namespace
                        | "type" -> Type
                        | "module" -> Module
                        | t -> failwith $"unknown type %s{t} in %s{filename}"

                    let path =
                        uriPrefix
                        |> String.length
                        |> el.Uri.Substring

                    { Name = name
                      Type = typ
                      Path = path })

            filename, html, entries)


    let connectionString =
        let path = __SOURCE_DIRECTORY__ </> resourcesPath </> "docSet.dsidx"
        "Data Source=" + path + ";"
        + "Mode=ReadWriteCreate;"
        + "foreign keys=true"
    using (new SqliteConnection(connectionString)) (fun conn ->
        conn.Open()

        [ "CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);"
          "CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);" ]
        |> List.iter (fun sql ->
            use cmd = conn.CreateCommand()
            cmd.CommandText <- sql
            cmd.ExecuteNonQuery() |> ignore)

        use tx = conn.BeginTransaction()

        let cmd = conn.CreateCommand()
        cmd.CommandText <- "INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES ($name, $type, $path);"
        let nameParam, typeParam, pathParam =
            let mkParam name =
                let p = cmd.CreateParameter()
                p.ParameterName <- name
                cmd.Parameters.Add p
            mkParam "$name", mkParam "$type", mkParam "$path"

        filesAndEntries
        |> Seq.iter (fun (filename, html, entries) ->
            File.WriteAllText (documentsPath </> filename, html)

            entries
            |> Seq.iter (fun entry ->
                nameParam.Value <- entry.Name
                typeParam.Value <- string entry.Type
                pathParam.Value <- entry.Path

                cmd.ExecuteNonQuery() |> ignore))

        tx.Commit()
    )

    let plist =
        $"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
    <string>FSharp.Core</string>
    <key>CFBundleName</key>
    <string>FSharp.Core</string>
    <key>DocSetPlatformFamily</key>
    <string>fsharp</string>
    <key>DashDocSetFallbackURL</key>
    <string>%s{uriPrefix}</string>
    <key>isDashDocset</key>
    <true/>
</dict>
</plist>"""

    File.WriteAllText (contentsPath</>"Info.plist", plist)

[<EntryPoint>]
let main args =
    Directory.SetCurrentDirectory (__SOURCE_DIRECTORY__ </> "..")

    match args with
    | [| "build-sources" |]
    | [| "sources" |] ->
        buildSources()
    | [| "build-docset" |]
    | [| "docset" |] ->
        buildDocSet()
    | [||] ->
        buildSources()
        buildDocSet()
    | _ ->
        failwith "Unknown command"

    0